# """
# Model exported as python (fixed to run in VS Code on macOS with QGIS-LTR).
# Name : model
# Group :
# With QGIS : 3.34 LTR
# """

import os, sys

# --- QGIS paths (macOS QGIS-LTR) ---
# If you still get import errors, start VS Code with the QGIS env as described earlier.
sys.path.append("/Applications/QGIS-LTR.app/Contents/Resources/python")
sys.path.append("/Applications/QGIS-LTR.app/Contents/Resources/python/plugins")
sys.path.append("/Applications/QGIS-LTR.app/Contents/MacOS/lib/python3.9/site-packages")

# Environment (helps with Qt/GDAL/PROJ on some setups)
os.environ["QGIS_PREFIX_PATH"] = "/Applications/QGIS-LTR.app/Contents/MacOS"
os.environ["QT_QPA_PLATFORM_PLUGIN_PATH"] = "/Applications/QGIS-LTR.app/Contents/PlugIns/platforms"
os.environ["GDAL_DATA"] = "/Applications/QGIS-LTR.app/Contents/Resources/gdal"
os.environ["PROJ_LIB"] = "/Applications/QGIS-LTR.app/Contents/Resources/proj"

from qgis.core import (
    QgsApplication, QgsVectorLayer, Qgis,
    QgsProcessing, QgsProcessingAlgorithm, QgsProcessingMultiStepFeedback,
    QgsProcessingParameterVectorLayer, QgsProcessingParameterFeatureSink,
    QgsProcessingParameterCrs, QgsProcessingParameterNumber,
    QgsProcessingContext, QgsProcessingFeedback,
    QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsProject
)

# Initialize QGIS (headless)
QgsApplication.setPrefixPath("/Applications/QGIS-LTR.app/Contents/MacOS", True)
qgs = QgsApplication([], False)
qgs.initQgis()
print("QGIS:", Qgis.QGIS_VERSION)

# Init processing
import processing
from processing.core.Processing import Processing
Processing.initialize()
print("processing OK")


class CreateClipped(QgsProcessingAlgorithm):
    P_INPUT = "input_layer"
    P_OUT = "ClippedResult"
    P_GRID_CRS = "grid_crs"
    P_SPACING = "grid_spacing"

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.P_INPUT,
                "Input layer (defines clip area & extent)",
                types=[QgsProcessing.TypeVectorAnyGeometry],
            )
        )
        self.addParameter(
            QgsProcessingParameterCrs(
                self.P_GRID_CRS,
                "Grid CRS",
                defaultValue=QgsCoordinateReferenceSystem("EPSG:2180"),
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.P_SPACING,
                "Grid spacing (map units)",
                type=QgsProcessingParameterNumber.Double,
                defaultValue=10000.0,
                minValue=1.0,
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.P_OUT,
                "Clipped result",
                type=QgsProcessing.TypeVectorAnyGeometry,
                createByDefault=True,
                defaultValue=None
            )
        )

    def processAlgorithm(self, parameters, context, model_feedback):
            # Use a multi-step feedback, so that individual child algorithm progress reports are adjusted for the
            # overall progress through the model
            feedback = QgsProcessingMultiStepFeedback(3, model_feedback)
            results = {}
            outputs = {}

            # Create grid
            alg_params = {
                'CRS': QgsCoordinateReferenceSystem('EPSG:2180'),
                'EXTENT': parameters['input_layer'],
                'HOVERLAY': 0,
                'HSPACING': 10000,
                'TYPE': 2,  # Rectangle (Polygon)
                'VOVERLAY': 0,
                'VSPACING': 10000,
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['CreateGrid'] = processing.run('native:creategrid', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

            feedback.setCurrentStep(1)
            if feedback.isCanceled():
                return {}

            # Create spatial index
            alg_params = {
                'INPUT': outputs['CreateGrid']['OUTPUT']
            }
            outputs['CreateSpatialIndex'] = processing.run('native:createspatialindex', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

            feedback.setCurrentStep(2)
            if feedback.isCanceled():
                return {}

            # Clip
            alg_params = {
                'INPUT': outputs['CreateSpatialIndex']['OUTPUT'],
                'OVERLAY': parameters['input_layer'],
                'OUTPUT': parameters['ClippedResult']
            }
            outputs['Clip'] = processing.run('native:clip', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
            results['ClippedResult'] = outputs['Clip']['OUTPUT']
            return results

    def name(self):
        return 'model'

    def displayName(self):
        return 'model'

    def group(self):
        return ''

    def groupId(self):
        return ''

    def createInstance(self):
        return CreateClipped()


# -------------------------
# Standalone execution part
# -------------------------
if __name__ == "__main__":
    # Example inputs
    input_path = "../input/dolnoslaskie_boundary_v1.geojson"
    output_path = "../output/clipped_result_1.geojson"   # or "/tmp/clipped.shp"
    grid_authid = "EPSG:2180"
    grid_spacing = 10000.0

    # Build parameter dict for the algorithm
    params = {
        CreateClipped.P_INPUT: input_path,
        CreateClipped.P_GRID_CRS: QgsCoordinateReferenceSystem(grid_authid),
        CreateClipped.P_SPACING: grid_spacing,
        CreateClipped.P_OUT: output_path,
    }

    # Create a processing context & feedback
    context = QgsProcessingContext()
    feedback = QgsProcessingFeedback()

    # Important: set a project/transform context for CRS transforms
    project = QgsProject.instance()
    context.setProject(project)

    # Run the algorithm class directly
    alg = CreateClipped()
    # Normally the framework calls initAlgorithm; when running directly it's safe to call it once:
    alg.initAlgorithm()
    result = alg.processAlgorithm(params, context, feedback)

    print("OK ->", result.get(CreateClipped.P_OUT))

    # Clean up QGIS
    # qgs.exitQgis()










# ================================== Initialiaztion ============================

# utils/PV_Pv_creategrid.py
# """
# Model exported as python (fixed to run in VS Code on macOS with QGIS-LTR).
# Name : model
# Group :
# With QGIS : 3.34 LTR
# """

import os, sys
from pathlib import Path
import argparse

# --- QGIS paths (macOS QGIS-LTR) ---
# If you still get import errors, start VS Code with the QGIS env as described earlier.
sys.path.append("/Applications/QGIS-LTR.app/Contents/Resources/python")
sys.path.append("/Applications/QGIS-LTR.app/Contents/Resources/python/plugins")
sys.path.append("/Applications/QGIS-LTR.app/Contents/MacOS/lib/python3.9/site-packages")

# Environment (helps with Qt/GDAL/PROJ on some setups)
os.environ["QGIS_PREFIX_PATH"] = "/Applications/QGIS-LTR.app/Contents/MacOS"
os.environ["QT_QPA_PLATFORM_PLUGIN_PATH"] = "/Applications/QGIS-LTR.app/Contents/PlugIns/platforms"
os.environ["GDAL_DATA"] = "/Applications/QGIS-LTR.app/Contents/Resources/gdal"
os.environ["PROJ_LIB"] = "/Applications/QGIS-LTR.app/Contents/Resources/proj"

from qgis.core import (
    QgsApplication, QgsVectorLayer, Qgis,
    QgsProcessing, QgsProcessingAlgorithm, QgsProcessingMultiStepFeedback,
    QgsProcessingParameterVectorLayer, QgsProcessingParameterFeatureSink,
    QgsProcessingParameterCrs, QgsProcessingParameterNumber,
    QgsProcessingContext, QgsProcessingFeedback,
    QgsCoordinateReferenceSystem, QgsProject
)

# Initialize QGIS (headless)
QgsApplication.setPrefixPath("/Applications/QGIS-LTR.app/Contents/MacOS", True)
qgs = QgsApplication([], False)
qgs.initQgis()
# print("QGIS:", Qgis.QGIS_VERSION)

# Init processing
import processing
from processing.core.Processing import Processing
Processing.initialize()
print("processing OK")

# ============================================== Main code =================================


class Pv_creategrid(QgsProcessingAlgorithm):

    P_INPUT = "input_vector_layer"
    P_OUT = "ClippedResult"
    P_GRID_CRS = "grid_crs"
    P_SPACING = "grid_spacing"

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.P_INPUT,
                "Input layer (defines clip area & extent)",
                types=[QgsProcessing.TypeVectorAnyGeometry],
            )
        )
        self.addParameter(
            QgsProcessingParameterCrs(
                self.P_GRID_CRS,
                "Grid CRS",
                defaultValue=QgsCoordinateReferenceSystem("EPSG:2180"),
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.P_SPACING,
                "Grid spacing (map units)",
                type=QgsProcessingParameterNumber.Double,
                defaultValue=10000.0,
                minValue=1.0,
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.P_OUT,
                "Clipped result",
                type=QgsProcessing.TypeVectorAnyGeometry,
                createByDefault=True,
                defaultValue=None
            )
        )

    def processAlgorithm(self, parameters, context, model_feedback):
        # Use a multi-step feedback, so that individual child algorithm progress reports are adjusted for the
        # overall progress through the model
        feedback = QgsProcessingMultiStepFeedback(4, model_feedback)
        results = {}
        outputs = {}

        # Create grid
        alg_params = {
            'CRS': QgsCoordinateReferenceSystem('EPSG:2180'),
            'EXTENT': parameters['input_vector_layer'],
            'HOVERLAY': 0,
            'HSPACING': 10000.0,
            'TYPE': 2,  # Rectangle (Polygon)
            'VOVERLAY': 0,
            'VSPACING': 10000.0,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['CreateGrid'] = processing.run('native:creategrid', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(1)
        if feedback.isCanceled():
            return {}

        # Create spatial index
        alg_params = {
            'INPUT': outputs['CreateGrid']['OUTPUT']
        }
        outputs['CreateSpatialIndex'] = processing.run('native:createspatialindex', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(2)
        if feedback.isCanceled():
            return {}

        # Clip
        alg_params = {
            'INPUT': outputs['CreateSpatialIndex']['OUTPUT'],
            'OVERLAY': parameters['input_vector_layer'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['Clip'] = processing.run('native:clip', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(3)
        if feedback.isCanceled():
            return {}

        # Add geometry attributes
        alg_params = {
            'CALC_METHOD': 0,  # Layer CRS
            'INPUT': outputs['Clip']['OUTPUT'],
            'OUTPUT': parameters['CreategridResult']
        }
        outputs['AddGeometryAttributes'] = processing.run('qgis:exportaddgeometrycolumns', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        results['CreategridResult'] = outputs['AddGeometryAttributes']['OUTPUT']
        return results

    def name(self):
        return 'PV_CreateGrid'

    def displayName(self):
        return 'PV_CreateGrid'

    def group(self):
        return ''

    def groupId(self):
        return ''

    def createInstance(self):
        return Pv_creategrid()


def run_create_clipped(
    input_path: str,
    output_path: str,
    grid_authid: str = "EPSG:2180",
    grid_spacing: float = 10000.0,
) -> str:
    """
    Programmatic entrypoint. Runs the Pv_creategrid algorithm and returns the output path.
    """
    # Build parameter dict for the algorithm
    params = {
        Pv_creategrid.P_INPUT: input_path,
        Pv_creategrid.P_GRID_CRS: QgsCoordinateReferenceSystem(grid_authid),
        Pv_creategrid.P_SPACING: float(grid_spacing),
        Pv_creategrid.P_OUT: output_path,
    }

    context = QgsProcessingContext()
    feedback = QgsProcessingFeedback()

    # Important: set a project/transform context for CRS transforms
    project = QgsProject.instance()
    context.setProject(project)

    alg = Pv_creategrid()
    alg.initAlgorithm()
    result = alg.processAlgorithm(params, context, feedback)

    return result.get(Pv_creategrid.P_OUT)


def _cli():
    parser = argparse.ArgumentParser(description="Create grid and clip by overlay.")
    parser.add_argument("--input", required=True, help="Path to input vector (extent/overlay), e.g. *.geojson")
    parser.add_argument("--output", required=True, help="Path for clipped output (e.g. *.geojson)")
    parser.add_argument("--crs", default="EPSG:2180", help="Grid CRS authid (default: EPSG:2180)")
    parser.add_argument("--spacing", type=float, default=10000.0, help="Grid spacing in map units (default: 10000)")
    args = parser.parse_args()

    out = run_create_clipped(args.input, args.output, args.crs, args.spacing)
    print("OK ->", out)


if __name__ == "__main__":
    _cli()
    # Clean up QGIS *only* when running as a standalone script
    # qgs.exitQgis()

































# ================================== Initialiaztion ============================

# utils/PV_Pv_creategrid.py
# """
# Model exported as python (fixed to run in VS Code on macOS with QGIS-LTR).
# Name : model
# Group :
# With QGIS : 3.34 LTR
# """

import os, sys
from pathlib import Path
import argparse

# --- QGIS paths (macOS QGIS-LTR) ---
# If you still get import errors, start VS Code with the QGIS env as described earlier.
sys.path.append("/Applications/QGIS-LTR.app/Contents/Resources/python")
sys.path.append("/Applications/QGIS-LTR.app/Contents/Resources/python/plugins")
sys.path.append("/Applications/QGIS-LTR.app/Contents/MacOS/lib/python3.9/site-packages")

# Environment (helps with Qt/GDAL/PROJ on some setups)
os.environ["QGIS_PREFIX_PATH"] = "/Applications/QGIS-LTR.app/Contents/MacOS"
os.environ["QT_QPA_PLATFORM_PLUGIN_PATH"] = "/Applications/QGIS-LTR.app/Contents/PlugIns/platforms"
os.environ["GDAL_DATA"] = "/Applications/QGIS-LTR.app/Contents/Resources/gdal"
os.environ["PROJ_LIB"] = "/Applications/QGIS-LTR.app/Contents/Resources/proj"

from qgis.core import (
    QgsApplication, QgsVectorLayer, Qgis,
    QgsProcessing, QgsProcessingAlgorithm, QgsProcessingMultiStepFeedback,
    QgsProcessingParameterVectorLayer, QgsProcessingParameterFeatureSink,
    QgsProcessingParameterCrs, QgsProcessingParameterNumber,
    QgsProcessingContext, QgsProcessingFeedback,
    QgsCoordinateReferenceSystem, QgsProject
)

# Initialize QGIS (headless)
QgsApplication.setPrefixPath("/Applications/QGIS-LTR.app/Contents/MacOS", True)
qgs = QgsApplication([], False)
qgs.initQgis()
# print("QGIS:", Qgis.QGIS_VERSION)

# Init processing
import processing
from processing.core.Processing import Processing
Processing.initialize()
print("processing OK")

# ============================================== Main code =================================

class Pv_creategrid(QgsProcessingAlgorithm):
    # ---- parameter keys (constants) ----
    P_INPUT = "input_vector_layer"
    P_HSPACING = "input_horizontal_spacing"
    P_VSPACING = "input_vertical_spacing"
    P_CRS = "input_crs"
    P_OUT = "CreategridResult"

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.P_INPUT,
                "Input vector layer",
                types=[QgsProcessing.TypeVectorAnyGeometry],
                defaultValue=None
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.P_VSPACING,
                "Input vertical spacing",
                type=QgsProcessingParameterNumber.Double,
                defaultValue=1000.0,
                minValue=0.000001
            )
        )
        self.addParameter(
            QgsProcessingParameterNumber(
                self.P_HSPACING,
                "Input horizontal spacing",
                type=QgsProcessingParameterNumber.Double,
                defaultValue=1000.0,
                minValue=0.000001
            )
        )
        self.addParameter(
            QgsProcessingParameterCrs(
                self.P_CRS,
                "Input CRS for grid",
                defaultValue="EPSG:2180"
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.P_OUT,
                "CreateGrid Result",
                type=QgsProcessing.TypeVectorAnyGeometry,
                createByDefault=True,
                defaultValue=None
            )
        )

def processAlgorithm(self, parameters, context, model_feedback):
    feedback = QgsProcessingMultiStepFeedback(4, model_feedback)
    results, outputs = {}, {}

    # --- Resolve inputs
    input_layer = _layer_from_any(parameters[self.P_INPUT])
    grid_crs = parameters[self.P_CRS]  # QgsCoordinateReferenceSystem
    hspacing = float(parameters[self.P_HSPACING])
    vspacing = float(parameters[self.P_VSPACING])

    if not input_layer.isValid():
        raise QgsProcessingException("Input layer is invalid.")
    if not grid_crs.isValid():
        raise QgsProcessingException("Grid CRS is invalid.")

    # --- Build EXTENT string in grid CRS
    src_extent = input_layer.extent()
    src_crs = input_layer.crs()
    grid_extent = _extent_in_crs(src_extent, src_crs, grid_crs)

    if grid_extent.width() <= 0 or grid_extent.height() <= 0:
        raise QgsProcessingException("Input extent has non-positive width/height.")

    extent_str = (
        f"{grid_extent.xMinimum()},{grid_extent.xMaximum()},"
        f"{grid_extent.yMinimum()},{grid_extent.yMaximum()} "
        f"[{grid_crs.authid()}]"
    )

    # --- Create grid
    alg_params = {
        "CRS": grid_crs,
        "EXTENT": extent_str,
        "HOVERLAY": 0.0,
        "HSPACING": hspacing,
        "TYPE": 2,  # rectangle polygons
        "VOVERLAY": 0.0,
        "VSPACING": vspacing,
        "OUTPUT": QgsProcessing.TEMPORARY_OUTPUT,
    }
    outputs["CreateGrid"] = processing.run(
        "native:creategrid", alg_params, context=context, feedback=feedback, is_child_algorithm=True
    )

    feedback.setCurrentStep(1)
    if feedback.isCanceled():
        return {}

    outputs["CreateSpatialIndex"] = processing.run(
        "native:createspatialindex",
        {"INPUT": outputs["CreateGrid"]["OUTPUT"]},
        context=context, feedback=feedback, is_child_algorithm=True
    )

    feedback.setCurrentStep(2)
    if feedback.isCanceled():
        return {}

    outputs["Clip"] = processing.run(
        "native:clip",
        {
            "INPUT": outputs["CreateSpatialIndex"]["OUTPUT"],
            "OVERLAY": input_layer,
            "OUTPUT": QgsProcessing.TEMPORARY_OUTPUT
        },
        context=context, feedback=feedback, is_child_algorithm=True
    )

    feedback.setCurrentStep(3)
    if feedback.isCanceled():
        return {}

    outputs["AddGeometryAttributes"] = processing.run(
        "qgis:exportaddgeometrycolumns",
        {
            "INPUT": outputs["Clip"]["OUTPUT"],
            "CALC_METHOD": 0,  # Layer CRS
            "OUTPUT": parameters[self.P_OUT]
        },
        context=context, feedback=feedback, is_child_algorithm=True
    )

    results[self.P_OUT] = outputs["AddGeometryAttributes"]["OUTPUT"]
    return results

    def name(self):
        return "PV_CreateGrid"

    def displayName(self):
        return "PV_CreateGrid"

    def group(self):
        return ""

    def groupId(self):
        return ""

    def createInstance(self):
        return Pv_creategrid()


# ============================ runner ============================

def run_create_clipped(
    input_path: str,
    output_path: str,
    input_horizontal_spacing: float,
    input_vertical_spacing: float,
    input_crs: str = "EPSG:2180",
) -> str:
    params = {
        Pv_creategrid.P_INPUT: input_path,
        Pv_creategrid.P_CRS: QgsCoordinateReferenceSystem(input_crs),
        Pv_creategrid.P_HSPACING: float(input_horizontal_spacing),
        Pv_creategrid.P_VSPACING: float(input_vertical_spacing),
        Pv_creategrid.P_OUT: output_path,
    }

    context = QgsProcessingContext()
    feedback = QgsProcessingFeedback()

    # ensure transform context exists
    project = QgsProject.instance()
    context.setProject(project)

    alg = Pv_creategrid()
    alg.initAlgorithm()
    result = alg.processAlgorithm(params, context, feedback)
    return result.get(Pv_creategrid.P_OUT)